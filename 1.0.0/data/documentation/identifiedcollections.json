{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"anchor":"Motivation","level":3,"type":"heading","text":"Motivation"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When modeling a collection of elements in your application‚Äôs state, it is easy to reach for a"},{"type":"text","text":" "},{"type":"text","text":"standard "},{"type":"codeVoice","code":"Array"},{"type":"text","text":". However, as your application becomes more complex, this approach can break down in"},{"type":"text","text":" "},{"type":"text","text":"many ways, including accidentally making mutations to the wrong elements or even crashing. üò¨"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, if you were building a ‚ÄúTodos‚Äù application in SwiftUI, you might model an individual"},{"type":"text","text":" "},{"type":"text","text":"todo in an identifiable value type:"}]},{"type":"codeListing","syntax":"swift","code":["struct Todo: Identifiable {","  var description = \"\"","  let id: UUID","  var isComplete = false","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And you would hold an array of these todos as a published field in your app‚Äôs view model:"}]},{"type":"codeListing","syntax":"swift","code":["class TodosViewModel: ObservableObject {","  @Published var todos: [Todo] = []","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"A view can render a list of these todos quite simply, and because they are identifiable we can even"},{"type":"text","text":" "},{"type":"text","text":"omit the "},{"type":"codeVoice","code":"id"},{"type":"text","text":" parameter of "},{"type":"codeVoice","code":"List"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["struct TodosView: View {","  @ObservedObject var viewModel: TodosViewModel","  ","  var body: some View {","    List(self.viewModel.todos) { todo in","      ...","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If your deployment target is set to the latest version of SwiftUI, you may be tempted to pass along"},{"type":"text","text":" "},{"type":"text","text":"a binding to the list so that each row is given mutable access to its todo. This will work for"},{"type":"text","text":" "},{"type":"text","text":"simple cases, but as soon as you introduce side effects, like API clients or analytics, or want to"},{"type":"text","text":" "},{"type":"text","text":"write unit tests, you must push this logic into a view model, instead. And that means each row must"},{"type":"text","text":" "},{"type":"text","text":"be able to communicate its actions back to the view model."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You could do so by introducing some endpoints on the view model, like when a row‚Äôs completed toggle"},{"type":"text","text":" "},{"type":"text","text":"is changed:"}]},{"type":"codeListing","syntax":"swift","code":["class TodosViewModel: ObservableObject {","  ...","  func todoCheckboxToggled(at id: Todo.ID) {","    guard let index = self.todos.firstIndex(where: { $0.id == id })","    else { return }","    ","    self.todos[index].isComplete.toggle()","    \/\/ TODO: Update todo on backend using an API client","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This code is simple enough, but it can require a full traversal of the array to do its job."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Perhaps it would be more performant for a row to communicate its index back to the view model"},{"type":"text","text":" "},{"type":"text","text":"instead, and then it could mutate the todo directly via its index subscript. But this makes the view"},{"type":"text","text":" "},{"type":"text","text":"more complicated:"}]},{"type":"codeListing","syntax":"swift","code":["List(self.viewModel.todos.enumerated(), id: \\.element.id) { index, todo in","  ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This isn‚Äôt so bad, but at the moment it doesn‚Äôt even compile. An"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0312-indexed-and-enumerated-zip-collections.md"},{"type":"text","text":" "},{"type":"text","text":"may change that soon, but in the meantime "},{"type":"codeVoice","code":"List"},{"type":"text","text":" and "},{"type":"codeVoice","code":"ForEach"},{"type":"text","text":" must be passed a"},{"type":"text","text":" "},{"type":"codeVoice","code":"RandomAccessCollection"},{"type":"text","text":", which is perhaps most simply achieved by constructing another array:"}]},{"type":"codeListing","syntax":"swift","code":["List(Array(self.viewModel.todos.enumerated()), id: \\.element.id) { index, todo in","  ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This compiles, but we‚Äôve just moved the performance problem to the view: every time this body is"},{"type":"text","text":" "},{"type":"text","text":"evaluated there‚Äôs the possibility a whole new array is being allocated."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"But even if it were possible to pass an enumerated collection directly to these views, identifying"},{"type":"text","text":" "},{"type":"text","text":"an element of mutable state by an index introduces a number of other problems."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"While it‚Äôs true that we can greatly simplify and improve the performance of any view model methods"},{"type":"text","text":" "},{"type":"text","text":"that mutate an element through its index subscript:"}]},{"type":"codeListing","syntax":"swift","code":["class TodosViewModel: ObservableObject {","  ...","  func todoCheckboxToggled(at index: Int) {","    self.todos[index].isComplete.toggle()","    \/\/ TODO: Update todo on backend using an API client","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Any asynchronous work that we add to this endpoint must take great care in "},{"type":"emphasis","inlineContent":[{"type":"text","text":"not"}]},{"type":"text","text":" using this index"},{"type":"text","text":" "},{"type":"text","text":"later on. An index is not a stable identifier: todos can be moved and removed at any time, and an"},{"type":"text","text":" "},{"type":"text","text":"index identifying ‚ÄúBuy lettuce‚Äù at one moment may identify ‚ÄúCall Mom‚Äù the next, or worse, may be a"},{"type":"text","text":" "},{"type":"text","text":"completely invalid index and crash your application!"}]},{"type":"codeListing","syntax":"swift","code":["class TodosViewModel: ObservableObject {","  ...","  func todoCheckboxToggled(at index: Int) async {","    self.todos[index].isComplete.toggle()","    ","    do {","      \/\/ ‚ùå Could update the wrong todo, or crash!","      self.todos[index] = try await self.apiClient.updateTodo(self.todos[index]) ","    } catch {","      \/\/ Handle error","    }","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Whenever you need to access a particular todo after performing some asynchronous work, you "},{"type":"emphasis","inlineContent":[{"type":"text","text":"must"}]},{"type":"text","text":" do"},{"type":"text","text":" "},{"type":"text","text":"the work of traversing the array:"}]},{"type":"codeListing","syntax":"swift","code":["class TodosViewModel: ObservableObject {","  ...","  func todoCheckboxToggled(at index: Int) async {","    self.todos[index].isComplete.toggle()","    ","    \/\/ 1Ô∏è‚É£ Get a reference to the todo's id before kicking off the async work","    let id = self.todos[index].id","  ","    do {","      \/\/ 2Ô∏è‚É£ Update the todo on the backend","      let updatedTodo = try await self.apiClient.updateTodo(self.todos[index])","              ","      \/\/ 3Ô∏è‚É£ Find the updated index of the todo after the async work is done","      let updatedIndex = self.todos.firstIndex(where: { $0.id == id })!","      ","      \/\/ 4Ô∏è‚É£ Update the correct todo","      self.todos[updatedIndex] = updatedTodo","    } catch {","      \/\/ Handle error","    }","  }","}"]},{"anchor":"Introducing-identified-collections","level":3,"type":"heading","text":"Introducing: identified collections"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Identified collections are designed to solve all of these problems by providing data structures for"},{"type":"text","text":" "},{"type":"text","text":"working with collections of identifiable elements in an ergonomic, performant way."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Most of the time, you can simply swap an "},{"type":"codeVoice","code":"Array"},{"type":"text","text":" out for an "},{"type":"codeVoice","code":"IdentifiedArray"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["import IdentifiedCollections","","class TodosViewModel: ObservableObject {","  @Published var todos: IdentifiedArrayOf<Todo> = []","  ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And then you can mutate an element directly via its id-based subscript, no traversals needed, even"},{"type":"text","text":" "},{"type":"text","text":"after asynchronous work is performed:"}]},{"type":"codeListing","syntax":"swift","code":["class TodosViewModel: ObservableObject {","  ...","  func todoCheckboxToggled(at id: Todo.ID) async {","    self.todos[id: id]?.isComplete.toggle()","    ","    do {","      \/\/ 1Ô∏è‚É£ Update todo on backend and mutate it in the todos identified array.","      self.todos[id: id] = try await self.apiClient.updateTodo(self.todos[id: id]!)","    } catch {","      \/\/ Handle error","    }","","    \/\/ No step 2Ô∏è‚É£ üòÜ","  }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can also simply pass the identified array to views like "},{"type":"codeVoice","code":"List"},{"type":"text","text":" and "},{"type":"codeVoice","code":"ForEach"},{"type":"text","text":" without any"},{"type":"text","text":" "},{"type":"text","text":"complications:"}]},{"type":"codeListing","syntax":"swift","code":["List(self.viewModel.todos) { todo in","  ...","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Identified arrays are designed to integrate with SwiftUI applications, as well as applications"},{"type":"text","text":" "},{"type":"text","text":"written in"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/pointfreeco\/swift-composable-architecture"},{"type":"text","text":"."}]},{"anchor":"Design","level":3,"type":"heading","text":"Design"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"IdentifiedArray"},{"type":"text","text":" is a lightweight wrapper around the"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-collections\/blob\/main\/Documentation\/OrderedDictionary.md"},{"type":"text","text":" type from Apple‚Äôs "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-collections"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"It shares many of the same performance characteristics and design considerations, but is better"},{"type":"text","text":" "},{"type":"text","text":"adapted to solving the problem of holding onto a collection of "},{"type":"emphasis","inlineContent":[{"type":"text","text":"identifiable"}]},{"type":"text","text":" elements in your"},{"type":"text","text":" "},{"type":"text","text":"application‚Äôs state."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"IdentifiedArray"},{"type":"text","text":" does not expose any of the details of "},{"type":"codeVoice","code":"OrderedDictionary"},{"type":"text","text":" that may lead to"},{"type":"text","text":" "},{"type":"text","text":"breaking invariants. For example an "},{"type":"codeVoice","code":"OrderedDictionary<ID, Identifiable>"},{"type":"text","text":" may freely hold a value"},{"type":"text","text":" "},{"type":"text","text":"whose identifier does not match its key or multiple values could have the same id, and"},{"type":"text","text":" "},{"type":"codeVoice","code":"IdentifiedArray"},{"type":"text","text":" does not allow for these situations."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"And unlike"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-collections\/blob\/main\/Documentation\/OrderedSet.md"},{"type":"text","text":","},{"type":"text","text":" "},{"type":"codeVoice","code":"IdentifiedArray"},{"type":"text","text":" does not require that its "},{"type":"codeVoice","code":"Element"},{"type":"text","text":" type conforms to the "},{"type":"codeVoice","code":"Hashable"},{"type":"text","text":" protocol,"},{"type":"text","text":" "},{"type":"text","text":"which may be difficult or impossible to do, and introduces questions around the quality of hashing,"},{"type":"text","text":" "},{"type":"text","text":"etc."}]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"IdentifiedArray"},{"type":"text","text":" does not even require that its "},{"type":"codeVoice","code":"Element"},{"type":"text","text":" conforms to "},{"type":"codeVoice","code":"Identifiable"},{"type":"text","text":". Just as"},{"type":"text","text":" "},{"type":"text","text":"SwiftUI‚Äôs "},{"type":"codeVoice","code":"List"},{"type":"text","text":" and "},{"type":"codeVoice","code":"ForEach"},{"type":"text","text":" views take an "},{"type":"codeVoice","code":"id"},{"type":"text","text":" key path to an element‚Äôs identifier,"},{"type":"text","text":" "},{"type":"codeVoice","code":"IdentifiedArray"},{"type":"text","text":"s can be constructed with a key path:"}]},{"type":"codeListing","syntax":"swift","code":["var numbers = IdentifiedArray(id: \\Int.self)"]},{"anchor":"Performance","level":3,"type":"heading","text":"Performance"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"IdentifiedArray"},{"type":"text","text":" is designed to match the performance characteristics of "},{"type":"codeVoice","code":"OrderedDictionary"},{"type":"text","text":"."},{"type":"text","text":" "},{"type":"text","text":"It has been benchmarked with"},{"type":"text","text":" "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-collections-benchmark"},{"type":"text","text":":"}]},{"type":"paragraph","inlineContent":[{"type":"image","identifier":"benchmark.png"}]},{"anchor":"Installation","level":3,"type":"heading","text":"Installation"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can add Identified Collections to an Xcode project by adding it as a package dependency."}]},{"type":"paragraph","inlineContent":[{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/pointfreeco\/swift-identified-collections"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If you want to use Identified Collections in a "},{"type":"reference","isActive":true,"identifier":"https:\/\/swift.org\/package-manager\/"},{"type":"text","text":" "},{"type":"text","text":"project, it‚Äôs as simple as adding a "},{"type":"codeVoice","code":"dependencies"},{"type":"text","text":" clause to your "},{"type":"codeVoice","code":"Package.swift"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["dependencies: [","  .package(url: \"https:\/\/github.com\/pointfreeco\/swift-identified-collections\", from: \"0.5.0\")","],"]}]}],"schemaVersion":{"major":0,"minor":3,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/identifiedcollections"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/IdentifiedCollections\/documentation\/IdentifiedCollections","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"A library of data structures for working with collections of identifiable elements in an ergonomic,"},{"type":"text","text":" "},{"type":"text","text":"performant way."}],"kind":"symbol","metadata":{"roleHeading":"Framework","externalID":"IdentifiedCollections","title":"IdentifiedCollections","symbolKind":"module","role":"collection","modules":[{"name":"IdentifiedCollections"}]},"hierarchy":{"paths":[[]]},"topicSections":[{"title":"Collections","identifiers":["doc:\/\/IdentifiedCollections\/documentation\/IdentifiedCollections\/IdentifiedArray"]},{"title":"Structures","identifiers":["doc:\/\/IdentifiedCollections\/documentation\/IdentifiedCollections\/Identified"]},{"title":"Type Aliases","identifiers":["doc:\/\/IdentifiedCollections\/documentation\/IdentifiedCollections\/IdentifiedArrayOf"]}],"references":{"https://github.com/apple/swift-collections":{"title":"Swift Collections","titleInlineContent":[{"type":"text","text":"Swift Collections"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-collections","url":"https:\/\/github.com\/apple\/swift-collections"},"benchmark.png":{"alt":null,"type":"image","identifier":"benchmark.png","variants":[{"url":"\/images\/benchmark.png","traits":["1x","light"]}]},"doc://IdentifiedCollections/documentation/IdentifiedCollections/Identified":{"role":"symbol","title":"Identified","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Identified"}],"abstract":[{"type":"text","text":"A wrapper around a value and a hashable identifier that conforms to identifiable."}],"identifier":"doc:\/\/IdentifiedCollections\/documentation\/IdentifiedCollections\/Identified","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Identified"}],"url":"\/documentation\/identifiedcollections\/identified"},"https://github.com/apple/swift-collections/blob/main/Documentation/OrderedDictionary.md":{"title":"OrderedDictionary","titleInlineContent":[{"type":"codeVoice","code":"OrderedDictionary"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-collections\/blob\/main\/Documentation\/OrderedDictionary.md","url":"https:\/\/github.com\/apple\/swift-collections\/blob\/main\/Documentation\/OrderedDictionary.md"},"https://github.com/apple/swift-collections/blob/main/Documentation/OrderedSet.md":{"title":"OrderedSet","titleInlineContent":[{"type":"codeVoice","code":"OrderedSet"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-collections\/blob\/main\/Documentation\/OrderedSet.md","url":"https:\/\/github.com\/apple\/swift-collections\/blob\/main\/Documentation\/OrderedSet.md"},"https://github.com/pointfreeco/swift-composable-architecture":{"title":"the Composable Architecture","titleInlineContent":[{"type":"text","text":"the Composable Architecture"}],"type":"link","identifier":"https:\/\/github.com\/pointfreeco\/swift-composable-architecture","url":"https:\/\/github.com\/pointfreeco\/swift-composable-architecture"},"https://swift.org/package-manager/":{"title":"SwiftPM","titleInlineContent":[{"type":"text","text":"SwiftPM"}],"type":"link","identifier":"https:\/\/swift.org\/package-manager\/","url":"https:\/\/swift.org\/package-manager\/"},"doc://IdentifiedCollections/documentation/IdentifiedCollections/IdentifiedArray":{"role":"symbol","title":"IdentifiedArray","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"IdentifiedArray"}],"abstract":[{"type":"text","text":"An ordered collection of identifiable elements."}],"identifier":"doc:\/\/IdentifiedCollections\/documentation\/IdentifiedCollections\/IdentifiedArray","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IdentifiedArray"}],"url":"\/documentation\/identifiedcollections\/identifiedarray"},"https://github.com/apple/swift-collections-benchmark":{"title":"Swift Collections Benchmark","titleInlineContent":[{"type":"text","text":"Swift Collections Benchmark"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-collections-benchmark","url":"https:\/\/github.com\/apple\/swift-collections-benchmark"},"doc://IdentifiedCollections/documentation/IdentifiedCollections/IdentifiedArrayOf":{"role":"symbol","title":"IdentifiedArrayOf","fragments":[{"kind":"keyword","text":"typealias"},{"kind":"text","text":" "},{"kind":"identifier","text":"IdentifiedArrayOf"}],"abstract":[{"type":"text","text":"A convenience type alias that specifies an "},{"type":"reference","isActive":true,"identifier":"doc:\/\/IdentifiedCollections\/documentation\/IdentifiedCollections\/IdentifiedArray"},{"type":"text","text":" by an element conforming to the"},{"type":"text","text":" "},{"type":"codeVoice","code":"Identifiable"},{"type":"text","text":" protocol."}],"identifier":"doc:\/\/IdentifiedCollections\/documentation\/IdentifiedCollections\/IdentifiedArrayOf","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"IdentifiedArrayOf"}],"url":"\/documentation\/identifiedcollections\/identifiedarrayof"},"https://github.com/apple/swift-evolution/blob/main/proposals/0312-indexed-and-enumerated-zip-collections.md":{"title":"evolution proposal","titleInlineContent":[{"type":"text","text":"evolution proposal"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0312-indexed-and-enumerated-zip-collections.md","url":"https:\/\/github.com\/apple\/swift-evolution\/blob\/main\/proposals\/0312-indexed-and-enumerated-zip-collections.md"},"doc://IdentifiedCollections/documentation/IdentifiedCollections":{"role":"collection","title":"IdentifiedCollections","abstract":[{"type":"text","text":"A library of data structures for working with collections of identifiable elements in an ergonomic,"},{"type":"text","text":" "},{"type":"text","text":"performant way."}],"identifier":"doc:\/\/IdentifiedCollections\/documentation\/IdentifiedCollections","kind":"symbol","type":"topic","url":"\/documentation\/identifiedcollections"},"https://github.com/pointfreeco/swift-identified-collections":{"title":"https:\/\/github.com\/pointfreeco\/swift-identified-collections","titleInlineContent":[{"type":"text","text":"https:\/\/github.com\/pointfreeco\/swift-identified-collections"}],"type":"link","identifier":"https:\/\/github.com\/pointfreeco\/swift-identified-collections","url":"https:\/\/github.com\/pointfreeco\/swift-identified-collections"}}}